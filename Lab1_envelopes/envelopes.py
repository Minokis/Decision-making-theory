import numpy as np
#import matplotlib.pyplot as plt
from random import seed, randrange
import math

# Правило формирования конвертов (см readme.txt):
# Ведущий выбирает случайное число S, распределенное по какому-то закону P(x). Это - сумма X и Y, при этому X и Y
# распределяются по конвертам случайно.
# то есть, P(X=2/3S) = 1/2 и P(X=1/3S) = 1/2

# Рассмотрим пример с экспоненциальным распределением F(x) = 1 - e^(-lx)
# обратная функция -1/l * ln(1-x), вместо x подставлять выборку из равномерного распределения
# плотность распределения:

# Проведите численное моделирование игры:
# сгенерируйте выборку значений суммы в двух конвертах,
# разложите случайным образом суммы по конвертам.
# Отметьте реализации игры, в которых вам достался конверт с наибольшей суммой,
# для всех реализаций посчитайте величину выигрыша при обмене конвертами.
# Сгруппировав игры по близким значениям сумм в конверте первого игрока, посчитайте долю реализаций
# с большей суммой в конверте первого игрока и средний выигрыш первого игрока при обмене конвертами
# внутри каждой группы. Постройте графики оценки условной вероятности получить конверт с максимальной суммой
# и условного математического ожидания выигрыша при обмене конвертами, как функции от числа денег в конверте игрока X.

# Итерация 1:
# построить простенький график, чтобы проверить, действительно ли получаем результаты по экспоненте
# для этого вбить значения в массив
lam = 2
iterations = 10000
def IntFunc(x):
    return 1-pow(math.e, (-lam * x))

# def Density(x):
#     return something

def ReverseFunc(x):
    return -1/lam*math.log(1-x)


print(ReverseFunc(IntFunc(3)))
#
# seed()
# S = []
# for i in range(iterations):
#     S.append(ReverseFunc(randrange(0,1)))
# # как построить график? гистограмма по интервалам?
# # График для экспоненты (допустим)
#
# x = np.arange(0, 1000, 1)
# plt.plot(x, [IntFunc(i) for i in x])

# Итерация 2:
# Сумма случайно делится на X и Y, посчитать, сколько раз выиграла стратегия менять конверт

